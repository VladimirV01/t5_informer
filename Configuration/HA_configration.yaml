template:
  - trigger: 
    # This one uses the service to poll the calendar events and parse the result in a sensor which is passed to ESPHome
      - platform: time_pattern
        minutes: /30 # Every half an hour
        # minutes: /1 # Every minute
    action:
      - action: calendar.get_events
        target:
          entity_id: calendar.personal
        data:
          duration:
            hours: 72  # Get the events for the next 3 days
        response_variable: scheduled_events
    sensor:
      - name: Vladimir's Scheduled Events
        unique_id: vladimir_scheduled_events
        state: "{{ scheduled_events['calendar.personal']['events'] | count() }}"  # This state gives the number of the events in the next 72 hours (3 days)
        attributes: >
          scheduled_events: "{{ scheduled_events['calendar.personal']['events'] }}"
          {% set events = scheduled_events['calendar.personal']['events'] | sort(attribute="start") %}
          {% set event_count = events | count() %}

          {% for i in range(3) %}
            event{{ i + 1 }}_summary: >
              {% if event_count > i %}
                {{ events[i].summary if events[i].summary is defined else 'No summary available' }}
              {% else %}
                Unavailable
              {% endif %}
            event{{ i + 1 }}_start: >
              {% if event_count > i %}
                {{ events[i].start if events[i].start is defined else 'No start time available' }}
              {% else %}
                Unavailable
              {% endif %}
          {% endfor %}

        icon: mdi:calendar
  
  # ------------------------------------------------------------------ USE THIS IF YOU POLL THE FORECAST HOURLY -------------------------------------------------------------------
  - trigger: 
      # This one polls the forecast data from the openweathermap service. 
      # Since I use the free version of the service, only hourly forecast is available (which actually returns forecast for every 3 hours, not for every hour) so I had to work around that.
      - platform: time_pattern
        minutes: /30 # Update this sensor every half an hour
    action:
      - action: weather.get_forecasts
        target:
          entity_id: weather.openweathermap
        data:
          type: hourly
        response_variable: full_data
      - action: logbook.log
        data:
          name: Weather Forecast Log
          message: >
            Weather forecast data retrieved. Forecast count: {{
            full_data['weather.openweathermap']['forecast'] | list | count }} 
            for the next 72 hours.
          level: info
    sensor:
      - name: Filtered Forecast
        unique_id: filtered_weather_forecast
        state: "{{ now().date().strftime('%A') }}"  # Current day name
        icon: mdi:weather-cloudy-clock
        attributes: >
          {% set forecast_data = full_data['weather.openweathermap']['forecast'] %}
           # Define the current date
          {% set current_date = now().date() %}

          # Loop for the next 3 days (day1, day2, day3)
          {% for i in range(1, 4) %}
            {% set day = current_date + timedelta(days=i) %}
            {% set day_forecast = forecast_data | selectattr('datetime', 'search', day | string) %}
            {% set forecast_count = day_forecast | list | count %}
            
             # Variables for convenience
            {% set temperatures = day_forecast | map(attribute='temperature') | default([0]) %}
            {% set prec_probabilities = day_forecast | map(attribute='precipitation_probability') | default([0]) %}
            {% set conditions = day_forecast | map(attribute='condition') | default([0]) %}
            {% set precipitations = day_forecast | map(attribute='precipitation') | default([0]) %}

            day{{ i }}: "{{ day.strftime('%a') }}"  # Day name (3 letters)
            day{{ i }}_min: "{{ temperatures | list | min if forecast_count > 0 else 'Unavailable' }}"
            day{{ i }}_max: "{{ temperatures | list | max if forecast_count > 0 else 'Unavailable' }}"
            day{{ i }}_prec_prob: "{{ (prec_probabilities | list | sum / forecast_count) if forecast_count > 0 else 'Unavailable' }}"
            day{{ i }}_condition: "{{ conditions | first if forecast_count > 5 else 'Unavailable' }}"
            day{{ i }}_precipitation: "{{ (precipitations | list | sum / forecast_count) if forecast_count > 0 else 'Unavailable' }}"
          {% endfor %}

# ------------------------------------------------------------------ USE THIS IF YOU POLL THE FORECAST DAILY -------------------------------------------------------------------
  - trigger: 
      # This one polls the forecast data from the openweathermap service. 
      # Since I use the free version of the service, only hourly forecast is available (which actually returns forecast for every 3 hours, not for every hour) so I had to work around that.
      - platform: time_pattern
        hours: /1 # Update this sensor every hour. You can change it to less if you wish
    action:
      - action: weather.get_forecasts
        target:
          entity_id: weather.openweathermap
        data:
          type: daily
        response_variable: full_data
      - action: logbook.log
        data:
          name: Weather Forecast Log
          message: >
            Weather forecast data retrieved. Forecast count: {{
            full_data['weather.openweathermap']['forecast'] | list | count }} 
            for the next 72 hours.
          level: info
    sensor:
      - name: Filtered Forecast
        unique_id: filtered_weather_forecast
        state: "{{ now().date().strftime('%A') }}"  # Current day name
        icon: mdi:weather-cloudy-clock
        attributes: >
          {% set forecast_data = full_data['weather.openweathermap']['forecast'] %}
           # Define the current date
          {% set current_date = now().date() %}

          # Loop for the next 3 days (day1, day2, day3)
          {% for i in range(1, 4) %}
            {% set day = current_date + timedelta(days=i) %}
            {% set day_forecast = forecast_data | selectattr('datetime', 'search', day | string) | first %}

            day{{ i }}: "{{ day.strftime('%a') }}"  # Day name (3 letters)
            day{{ i }}_min: "{{ day_forecast.templow | default('Unavailable') }}"
            day{{ i }}_max: "{{ day_forecast.temperature | default('Unavailable') }}"
            day{{ i }}_prec_prob: "{{ day_forecast.precipitation_probability | default('Unavailable') }}"
            day{{ i }}_condition: "{{ day_forecast.condition | default('Unavailable') }}"
            day{{ i }}_precipitation: "{{ day_forecast.precipitation | default('Unavailable') }}"
          {% endfor %}
        